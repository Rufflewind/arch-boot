#!/bin/sh
#
# Before creating a new release
# -----------------------------
#
# 1. Is it bundled with GHC?
#    If so, mention it in the .cabal description and changelog.md.
# 2. Bump version as needed.
# 3. Update changelog: are all changes included? is the date correct?
#
# To create a new release
# -----------------------
#
# 1. Create a changelog diff `tagmsg` (no heading)
# 2. Copy `tagmsg` to `tagmsg.md` and GitHub-Markdown-ify it.
#    ( pandoc -t markdown_github changelog.md )
# 3. Run the following (in this order):
#
#     release-hs-package tag
#     release-hs-package package
#     release-hs-package release
#
# ----------------------------------------------------------------------------
# configuration
# ----------------------------------------------------------------------------
#
# The `.release.conf` file should be in the following format:
#
#     tag_signer=<key>                        # GPG key ID
#     github_user=<username>                  # username of the main repo
#     github_cred() { gpg -d <file>; }
#     hackage_cred() { gpg -d <file>; }
#
# The `github_cred` function should output:
#
#     header="Authorization: token <token>"
#
# where the token is obtained from: https://github.com/settings/tokens
# Make sure `public_repo` access is enabled.
#
# The `hackage_cred` function should output:
#
#     user="<username>:<password>"
#
# ----------------------------------------------------------------------------
# todo
# ----------------------------------------------------------------------------
#
# - more robustness
# - make it easier to use
# - double-check that --tags pushes ONLY tags
# - don't use https:// when pushing tags to origin
#
set -eu

. ./.release.conf

# make sure the config file is valid
: $tag_signer $github_user
github_cred >/dev/null
hackage_cred >/dev/null

for cabalfile in *.cabal
do
    if [ "${name+x}" ]
    then
        echo >&2 "error: multiple .cabal files"
        exit 1
    fi
    name=`grep '^name:' "$cabalfile" | awk '{ print $2; exit; }'`
done
version=`grep '^version:' "$name.cabal" | awk '{ print $2; exit; }'`
package=$name-$version
package_basename=$package.tar.gz
package_filename=dist/$package_basename

tag_name=v$version
tag_message=tagmsg

github_repo=$name
github_release_title="$name $version"
github_release_body=tagmsg.md
github_release_draft=true
github_release_prerelease=false

# ----------------------------------------------------------------------------
# initialize globals
# ----------------------------------------------------------------------------

progfull=$0
prog=`basename "$progfull"`
if [ -z "$XDG_RUNTIME_DIR" ]
then
    printf "%s: variable XDG_RUNTIME_DIR must be set\n" "$prog" >&2
    exit 1
fi
tmpprefix=$XDG_RUNTIME_DIR/rf-sh
umask 077 && mkdir -p $tmpprefix

if [ ! -r "$github_release_body" ]
then
    printf "%s: cannot read: %s\n" "$prog" "$github_release_body" >&2
    exit 1
fi

# ----------------------------------------------------------------------------
# basic functions
# ----------------------------------------------------------------------------

create_signed_tag() {
    tmp=$tmpprefix/github_create_release.$$
    {
        printf "%s\n\n" "$name $version"
        cat "$tag_message"
    } >"$tmp"
    git tag -a -s -F "$tmp" -u "$tag_signer" "$tag_name"
    rm "$tmp"
}

create_tarball() {
    autoreconf -fi
    cabal configure
    cabal sdist
}

hackage_exists() {
    curl -fsLS >/dev/null 2>&1 \
         https://hackage.haskell.org/package/$package ||
    curl -fsLS >/dev/null 2>&1 \
         https://hackage.haskell.org/package/$package/candidate
}

hackage_upload() {
    hackage_cred |
    curl >/dev/null -fsLS \
         -F package="@$package_filename" \
         https://hackage.haskell.org/packages/candidates
}

hackage_publish() {
    hackage_cred |
    curl >/dev/null -fsLS \
         -X POST \
         https://hackage.haskell.org/package/$package/candidate/publish
    hackage_cred |
    curl >/dev/null -fsLS \
         -X POST \
         https://hackage.haskell.org/package/$package/candidate/delete
}

github_create_release() {

    # create the release
    tmp=$tmpprefix/github_create_release.$$
    github_release_data=`python -c '
import json, sys
true=True
false=False
print(json.dumps({
  "tag_name": sys.argv[1],
  "name": sys.argv[2],
  "body": open(sys.argv[3], "rt").read(),
  "draft": '"$github_release_draft"',
  "prerelease": '"$github_release_prerelease"'
}))' "$tag_name" "$github_release_title" "$github_release_body"`
    github_cred |
    curl >"$tmp" -fsLS \
         -d "$github_release_data" \
         "https://api.github.com/repos/$github_user/$github_repo/releases"

    # extract the upload_url
    _vars=`python -c '
import json, re, sys
def escape(s): return "\x27" + s.replace("\x27", "\x27\\\x27\x27") + "\x27"
fn = sys.argv[1]
with open(fn) as f:
    d = json.load(f)
upload_url = re.match(r"(.*)\{\?.*\}", d["upload_url"]).group(1)
s = "".join("{0}={1}\n".format(k, escape(v)) for k, v in {
    "github_release_upload_url": upload_url,
    "github_release_html_url": d["html_url"],
}.items())
print(s)
' "$tmp"`
    eval "$_vars"

    # upload the tarball
    github_cred |
    curl -fsLS \
         -H "Content-Type: application/x-gzip" \
         --data-binary "@$package_filename" \
         "$github_release_upload_url?name=$package_basename" \
         >/dev/null
}

# ----------------------------------------------------------------------------
# main functions
# ----------------------------------------------------------------------------

main_tag() {
    # make sure we are on 'master'
    current_branch=`git rev-parse --abbrev-ref HEAD`
    if [ "$current_branch" != master ]
    then
        printf "%s: not on 'master' branch\n" "$prog" >&2
        exit 1
    fi

    if git rev-parse "$tag_name" -- >/dev/null 2>&1
    then
        echo 'note: tag already exists; skipping ...'
    else
        create_signed_tag
        git push source --tags
        echo 'pushing tags to origin ...'
        git push origin --tags
    fi
    create_tarball
}

main_package() {
    if hackage_exists
    then
        echo 'note: Hackage package already exists; skipping ...'
        return
    fi
    hackage_upload

    printf 'note: you must publish the candidate manually by running:\n'
    printf '\n'
    printf '    %s hackage_publish\n' "$progfull"
    printf '\n'
    printf 'you can view the candidates here:\n'
    printf '\n'
    printf '    https://hackage.haskell.org/package/%s/candidates' "$package"
    printf '\n'
}

main_release() {
    github_create_release

    printf 'note: you must publish the release manually at:\n'
    printf '\n'
    printf '    %s\n' "$github_release_html_url"
    printf '\n'
}

case "$1" in
    hackage_publish)
        hackage_publish;;
    tag)
        main_tag;;
    package)
        main_package;;
    release)
        main_release;;
esac
